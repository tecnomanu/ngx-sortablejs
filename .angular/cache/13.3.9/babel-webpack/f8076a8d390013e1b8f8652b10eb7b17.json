{"ast":null,"code":"import { CommonModule } from '@angular/common';\nimport { Directive, Input, TemplateRef, ViewContainerRef, Injectable, Component, HostBinding, Renderer2, EventEmitter, Output, ElementRef, NgModule } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction TabsetComponent_li_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_li_1_span_4_Template_span_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const tabz_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n      const ctx_r3 = ɵngcc0.ɵɵnextContext();\n      $event.preventDefault();\n      return ctx_r3.removeTab(tabz_r1);\n    });\n    ɵngcc0.ɵɵtext(1, \" \\u274C\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nconst _c0 = function (a1) {\n  return [\"nav-item\", a1];\n};\n\nfunction TabsetComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 3)(1, \"a\", 4);\n    ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_li_1_Template_a_click_1_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7);\n      const tabz_r1 = restoredCtx.$implicit;\n      return tabz_r1.active = true;\n    });\n    ɵngcc0.ɵɵelementStart(2, \"span\", 5);\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(4, TabsetComponent_li_1_span_4_Template, 2, 0, \"span\", 6);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const tabz_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(13, _c0, tabz_r1.customClass || \"\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    ɵngcc0.ɵɵattribute(\"id\", tabz_r1.id ? tabz_r1.id + \"-link\" : \"\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTransclude\", tabz_r1.headingRef);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(tabz_r1.heading);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", tabz_r1.removable);\n  }\n}\n\nconst _c1 = [\"*\"];\nlet NgTranscludeDirective = /*#__PURE__*/(() => {\n  class NgTranscludeDirective {\n    /**\n     * @param {?} viewRef\n     */\n    constructor(viewRef) {\n      this.viewRef = viewRef;\n    }\n    /**\n     * @param {?} templateRef\n     * @return {?}\n     */\n\n\n    set ngTransclude(templateRef) {\n      this._ngTransclude = templateRef;\n\n      if (templateRef) {\n        this.viewRef.createEmbeddedView(templateRef);\n      }\n    }\n    /* tslint:disable-next-line:no-any */\n\n    /**\n     * @return {?}\n     */\n\n\n    get ngTransclude() {\n      return this._ngTransclude;\n    }\n\n  }\n\n  NgTranscludeDirective.ɵfac = function NgTranscludeDirective_Factory(t) {\n    return new (t || NgTranscludeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  NgTranscludeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgTranscludeDirective,\n    selectors: [[\"\", \"ngTransclude\", \"\"]],\n    inputs: {\n      ngTransclude: \"ngTransclude\"\n    }\n  });\n  /** @nocollapse */\n\n  return NgTranscludeDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet TabsetConfig = /*#__PURE__*/(() => {\n  class TabsetConfig {\n    constructor() {\n      /**\n       * provides default navigation context class: 'tabs' or 'pills'\n       */\n      this.type = 'tabs';\n    }\n\n  }\n\n  TabsetConfig.ɵfac = function TabsetConfig_Factory(t) {\n    return new (t || TabsetConfig)();\n  };\n\n  TabsetConfig.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TabsetConfig,\n    factory: TabsetConfig.ɵfac\n  });\n  return TabsetConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// todo: add active event to tab\n// todo: fix? mixing static and dynamic tabs position tabs in order of creation\n\n\nlet TabsetComponent = /*#__PURE__*/(() => {\n  class TabsetComponent {\n    /**\n     * @param {?} config\n     * @param {?} renderer\n     */\n    constructor(config, renderer) {\n      this.renderer = renderer;\n      this.clazz = true;\n      this.tabs = [];\n      this.classMap = {};\n      Object.assign(this, config);\n    }\n    /**\n     * if true tabs will be placed vertically\n     * @return {?}\n     */\n\n\n    get vertical() {\n      return this._vertical;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set vertical(value) {\n      this._vertical = value;\n      this.setClassMap();\n    }\n    /**\n     * if true tabs fill the container and have a consistent width\n     * @return {?}\n     */\n\n\n    get justified() {\n      return this._justified;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set justified(value) {\n      this._justified = value;\n      this.setClassMap();\n    }\n    /**\n     * navigation context class: 'tabs' or 'pills'\n     * @return {?}\n     */\n\n\n    get type() {\n      return this._type;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set type(value) {\n      this._type = value;\n      this.setClassMap();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.isDestroyed = true;\n    }\n    /**\n     * @param {?} tab\n     * @return {?}\n     */\n\n\n    addTab(tab) {\n      this.tabs.push(tab);\n      tab.active = this.tabs.length === 1 && typeof tab.active === 'undefined';\n    }\n    /**\n     * @param {?} tab\n     * @param {?=} options\n     * @return {?}\n     */\n\n\n    removeTab(tab, options = {\n      reselect: true,\n      emit: true\n    }) {\n      /** @type {?} */\n      const index = this.tabs.indexOf(tab);\n\n      if (index === -1 || this.isDestroyed) {\n        return;\n      } // Select a new tab if the tab to be removed is selected and not destroyed\n\n\n      if (options.reselect && tab.active && this.hasAvailableTabs(index)) {\n        /** @type {?} */\n        const newActiveIndex = this.getClosestTabIndex(index);\n        this.tabs[newActiveIndex].active = true;\n      }\n\n      if (options.emit) {\n        tab.removed.emit(tab);\n      }\n\n      this.tabs.splice(index, 1);\n\n      if (tab.elementRef.nativeElement.parentNode) {\n        this.renderer.removeChild(tab.elementRef.nativeElement.parentNode, tab.elementRef.nativeElement);\n      }\n    }\n    /**\n     * @protected\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    getClosestTabIndex(index) {\n      /** @type {?} */\n      const tabsLength = this.tabs.length;\n\n      if (!tabsLength) {\n        return -1;\n      }\n\n      for (let step = 1; step <= tabsLength; step += 1) {\n        /** @type {?} */\n        const prevIndex = index - step;\n        /** @type {?} */\n\n        const nextIndex = index + step;\n\n        if (this.tabs[prevIndex] && !this.tabs[prevIndex].disabled) {\n          return prevIndex;\n        }\n\n        if (this.tabs[nextIndex] && !this.tabs[nextIndex].disabled) {\n          return nextIndex;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * @protected\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    hasAvailableTabs(index) {\n      /** @type {?} */\n      const tabsLength = this.tabs.length;\n\n      if (!tabsLength) {\n        return false;\n      }\n\n      for (let i = 0; i < tabsLength; i += 1) {\n        if (!this.tabs[i].disabled && i !== index) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    setClassMap() {\n      this.classMap = {\n        'nav-stacked': this.vertical,\n        'flex-column': this.vertical,\n        'nav-justified': this.justified,\n        [`nav-${this.type}`]: true\n      };\n    }\n\n  }\n\n  TabsetComponent.ɵfac = function TabsetComponent_Factory(t) {\n    return new (t || TabsetComponent)(ɵngcc0.ɵɵdirectiveInject(TabsetConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  TabsetComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TabsetComponent,\n    selectors: [[\"tabset\"]],\n    hostVars: 2,\n    hostBindings: function TabsetComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"tab-container\", ctx.clazz);\n      }\n    },\n    inputs: {\n      vertical: \"vertical\",\n      justified: \"justified\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 2,\n    consts: [[1, \"nav\", 3, \"ngClass\", \"click\"], [3, \"ngClass\", \"active\", \"disabled\", 4, \"ngFor\", \"ngForOf\"], [1, \"tab-content\"], [3, \"ngClass\"], [\"href\", \"javascript:void(0);\", 1, \"nav-link\", 3, \"click\"], [3, \"ngTransclude\"], [\"class\", \"bs-remove-tab\", 3, \"click\", 4, \"ngIf\"], [1, \"bs-remove-tab\", 3, \"click\"]],\n    template: function TabsetComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0);\n        ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_Template_ul_click_0_listener($event) {\n          return $event.preventDefault();\n        });\n        ɵngcc0.ɵɵtemplate(1, TabsetComponent_li_1_Template, 5, 15, \"li\", 1);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.classMap);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.tabs);\n      }\n    },\n    directives: [ɵngcc1.NgClass, ɵngcc1.NgForOf, NgTranscludeDirective, ɵngcc1.NgIf],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TabsetComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet TabDirective = /*#__PURE__*/(() => {\n  class TabDirective {\n    /**\n     * @param {?} tabset\n     * @param {?} elementRef\n     * @param {?} renderer\n     */\n    constructor(tabset, elementRef, renderer) {\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      /**\n       * fired when tab became active, $event:Tab equals to selected instance of Tab component\n       */\n\n      this.selectTab = new EventEmitter();\n      /**\n       * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component\n       */\n\n      this.deselect = new EventEmitter();\n      /**\n       * fired before tab will be removed, $event:Tab equals to instance of removed tab\n       */\n\n      this.removed = new EventEmitter();\n      this.addClass = true;\n      this.tabset = tabset;\n      this.tabset.addTab(this);\n    }\n    /**\n     * if set, will be added to the tab's class attribute. Multiple classes are supported.\n     * @return {?}\n     */\n\n\n    get customClass() {\n      return this._customClass;\n    }\n    /**\n     * @param {?} customClass\n     * @return {?}\n     */\n\n\n    set customClass(customClass) {\n      if (this.customClass) {\n        this.customClass.split(' ').forEach(cssClass => {\n          this.renderer.removeClass(this.elementRef.nativeElement, cssClass);\n        });\n      }\n\n      this._customClass = customClass ? customClass.trim() : null;\n\n      if (this.customClass) {\n        this.customClass.split(' ').forEach(cssClass => {\n          this.renderer.addClass(this.elementRef.nativeElement, cssClass);\n        });\n      }\n    }\n    /**\n     * tab active state toggle\n     * @return {?}\n     */\n\n\n    get active() {\n      return this._active;\n    }\n    /**\n     * @param {?} active\n     * @return {?}\n     */\n\n\n    set active(active) {\n      if (this._active === active) {\n        return;\n      }\n\n      if (this.disabled && active || !active) {\n        if (this._active && !active) {\n          this.deselect.emit(this);\n          this._active = active;\n        }\n\n        return;\n      }\n\n      this._active = active;\n      this.selectTab.emit(this);\n      this.tabset.tabs.forEach(tab => {\n        if (tab !== this) {\n          tab.active = false;\n        }\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.removable = this.removable;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.tabset.removeTab(this, {\n        reselect: false,\n        emit: false\n      });\n    }\n\n  }\n\n  TabDirective.ɵfac = function TabDirective_Factory(t) {\n    return new (t || TabDirective)(ɵngcc0.ɵɵdirectiveInject(TabsetComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  TabDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TabDirective,\n    selectors: [[\"tab\"], [\"\", \"tab\", \"\"]],\n    hostVars: 5,\n    hostBindings: function TabDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.id);\n        ɵngcc0.ɵɵclassProp(\"tab-pane\", ctx.addClass)(\"active\", ctx.active);\n      }\n    },\n    inputs: {\n      customClass: \"customClass\",\n      active: \"active\",\n      removable: \"removable\",\n      heading: \"heading\",\n      id: \"id\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      selectTab: \"selectTab\",\n      deselect: \"deselect\",\n      removed: \"removed\"\n    }\n  });\n  /** @nocollapse */\n\n  return TabDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Should be used to mark <ng-template> element as a template for tab heading\n */\n\n\nlet TabHeadingDirective = /*#__PURE__*/(() => {\n  class TabHeadingDirective {\n    /* tslint:disable-next-line:no-any */\n\n    /**\n     * @param {?} templateRef\n     * @param {?} tab\n     */\n    constructor(templateRef, tab) {\n      tab.headingRef = templateRef;\n    }\n\n  }\n\n  TabHeadingDirective.ɵfac = function TabHeadingDirective_Factory(t) {\n    return new (t || TabHeadingDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(TabDirective));\n  };\n\n  TabHeadingDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TabHeadingDirective,\n    selectors: [[\"\", \"tabHeading\", \"\"]]\n  });\n  /** @nocollapse */\n\n  return TabHeadingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet TabsModule = /*#__PURE__*/(() => {\n  class TabsModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n      return {\n        ngModule: TabsModule,\n        providers: [TabsetConfig]\n      };\n    }\n\n  }\n\n  TabsModule.ɵfac = function TabsModule_Factory(t) {\n    return new (t || TabsModule)();\n  };\n\n  TabsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TabsModule\n  });\n  TabsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return TabsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsModule, {\n    declarations: function () {\n      return [NgTranscludeDirective, TabDirective, TabsetComponent, TabHeadingDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [TabDirective, TabsetComponent, TabHeadingDirective, NgTranscludeDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { NgTranscludeDirective, TabDirective, TabHeadingDirective, TabsetComponent, TabsetConfig, TabsModule }; //# sourceMappingURL=ngx-bootstrap-tabs.js.map","map":null,"metadata":{},"sourceType":"module"}