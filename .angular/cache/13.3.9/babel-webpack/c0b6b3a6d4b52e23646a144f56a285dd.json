{"ast":null,"code":"import { ElementRef, EventEmitter, NgZone, Renderer2, SimpleChange } from '@angular/core';\nimport Sortable from 'sortablejs';\nimport { GLOBALS } from './globals';\nimport { SortablejsBindings } from './sortablejs-bindings';\nimport { SortablejsService } from './sortablejs.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./sortablejs.service\";\n\nconst getIndexesFromEvent = event => {\n  if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {\n    return {\n      new: event.newDraggableIndex,\n      old: event.oldDraggableIndex\n    };\n  } else {\n    return {\n      new: event.newIndex,\n      old: event.oldIndex\n    };\n  }\n};\n\nexport let SortablejsDirective = /*#__PURE__*/(() => {\n  class SortablejsDirective {\n    constructor(globalConfig, service, element, zone, renderer) {\n      this.globalConfig = globalConfig;\n      this.service = service;\n      this.element = element;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.sortablejsInit = new EventEmitter();\n    }\n\n    ngOnInit() {\n      if (Sortable && Sortable.create) {\n        // Sortable does not exist in angular universal (SSR)\n        this.create();\n      }\n    }\n\n    ngOnChanges(changes) {\n      const optionsChange = changes.sortablejsOptions;\n\n      if (optionsChange && !optionsChange.isFirstChange()) {\n        const previousOptions = optionsChange.previousValue;\n        const currentOptions = optionsChange.currentValue;\n        Object.keys(currentOptions).forEach(optionName => {\n          if (currentOptions[optionName] !== previousOptions[optionName]) {\n            // use low-level option setter\n            this.sortableInstance.option(optionName, this.options[optionName]);\n          }\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.sortableInstance) {\n        this.sortableInstance.destroy();\n      }\n    }\n\n    create() {\n      const container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;\n      setTimeout(() => {\n        this.sortableInstance = Sortable.create(container, this.options);\n        this.sortablejsInit.emit(this.sortableInstance);\n      }, 0);\n    }\n\n    getBindings() {\n      if (!this.sortablejs) {\n        return new SortablejsBindings([]);\n      } else if (this.sortablejs instanceof SortablejsBindings) {\n        return this.sortablejs;\n      } else {\n        return new SortablejsBindings([this.sortablejs]);\n      }\n    }\n\n    get options() {\n      return Object.assign(Object.assign({}, this.optionsWithoutEvents), this.overridenOptions);\n    }\n\n    get optionsWithoutEvents() {\n      return Object.assign(Object.assign({}, this.globalConfig || {}), this.sortablejsOptions || {});\n    }\n\n    proxyEvent(eventName, ...params) {\n      this.zone.run(() => {\n        if (this.optionsWithoutEvents && this.optionsWithoutEvents[eventName]) {\n          this.optionsWithoutEvents[eventName](...params);\n        }\n      });\n    }\n\n    get isCloning() {\n      return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';\n    }\n\n    clone(item) {\n      // by default pass the item through, no cloning performed\n      return (this.sortablejsCloneFunction || (subitem => subitem))(item);\n    }\n\n    get overridenOptions() {\n      // always intercept standard events but act only in case items are set (bindingEnabled)\n      // allows to forget about tracking this.items changes\n      return {\n        onAdd: event => {\n          this.service.transfer = items => {\n            this.getBindings().injectIntoEvery(event.newIndex, items);\n            this.proxyEvent('onAdd', event);\n          };\n\n          this.proxyEvent('onAddOriginal', event);\n        },\n        onRemove: event => {\n          const bindings = this.getBindings();\n\n          if (bindings.provided) {\n            if (this.isCloning) {\n              this.service.transfer(bindings.getFromEvery(event.oldIndex).map(item => this.clone(item))); // great thanks to https://github.com/tauu\n              // event.item is the original item from the source list which is moved to the target list\n              // event.clone is a clone of the original item and will be added to source list\n              // If bindings are provided, adding the item dom element to the target list causes artifacts\n              // as it interferes with the rendering performed by the angular template.\n              // Therefore we remove it immediately and also move the original item back to the source list.\n              // (event handler may be attached to the original item and not its clone, therefore keeping\n              // the original dom node, circumvents side effects )\n\n              this.renderer.removeChild(event.item.parentNode, event.item);\n              this.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);\n              this.renderer.removeChild(event.clone.parentNode, event.clone);\n            } else {\n              this.service.transfer(bindings.extractFromEvery(event.oldIndex));\n            }\n\n            this.service.transfer = null;\n          }\n\n          this.proxyEvent('onRemove', event);\n        },\n        onUpdate: event => {\n          const bindings = this.getBindings();\n          const indexes = getIndexesFromEvent(event);\n          bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));\n          this.proxyEvent('onUpdate', event);\n        }\n      };\n    }\n\n  }\n\n  SortablejsDirective.ɵfac = function SortablejsDirective_Factory(t) {\n    return new (t || SortablejsDirective)(i0.ɵɵdirectiveInject(GLOBALS, 8), i0.ɵɵdirectiveInject(i1.SortablejsService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  SortablejsDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: SortablejsDirective,\n    selectors: [[\"\", \"sortablejs\", \"\"]],\n    inputs: {\n      sortablejs: \"sortablejs\",\n      sortablejsContainer: \"sortablejsContainer\",\n      sortablejsOptions: \"sortablejsOptions\",\n      sortablejsCloneFunction: \"sortablejsCloneFunction\"\n    },\n    outputs: {\n      sortablejsInit: \"sortablejsInit\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return SortablejsDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}