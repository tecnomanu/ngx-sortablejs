{"ast":null,"code":"import { isBs3, Utils, document as document$1, window as window$1 } from 'ngx-bootstrap/utils';\nimport { PositioningService } from 'ngx-bootstrap/positioning';\nimport { Injectable, Component, ElementRef, HostListener, Renderer2, Directive, EventEmitter, Input, Output, ViewContainerRef, RendererFactory2, NgModule } from '@angular/core';\nimport { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'ngx-bootstrap/component-loader';\nconst _c0 = [\"*\"];\nlet BsModalRef = /*#__PURE__*/(() => {\n  class BsModalRef {\n    constructor() {\n      /**\n       * Hides the modal\n       */\n      this.hide = Function;\n      /**\n       * Sets new class to modal window\n       */\n\n      this.setClass = Function;\n    }\n\n  }\n\n  BsModalRef.ɵfac = function BsModalRef_Factory(t) {\n    return new (t || BsModalRef)();\n  };\n\n  BsModalRef.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: BsModalRef,\n    factory: BsModalRef.ɵfac\n  });\n  return BsModalRef;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass ModalBackdropOptions {\n  /**\n   * @param {?} options\n   */\n  constructor(options) {\n    this.animate = true;\n    Object.assign(this, options);\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ModalOptions = /*#__PURE__*/(() => {\n  class ModalOptions {}\n\n  ModalOptions.ɵfac = function ModalOptions_Factory(t) {\n    return new (t || ModalOptions)();\n  };\n\n  ModalOptions.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ModalOptions,\n    factory: ModalOptions.ɵfac\n  });\n  return ModalOptions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** @type {?} */\n\n\nconst modalConfigDefaults = {\n  backdrop: true,\n  keyboard: true,\n  focus: true,\n  show: false,\n  ignoreBackdropClick: false,\n  class: '',\n  animated: true,\n  initialState: {}\n};\n/** @type {?} */\n\nconst CLASS_NAME = {\n  SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\n  BACKDROP: 'modal-backdrop',\n  OPEN: 'modal-open',\n  FADE: 'fade',\n  IN: 'in',\n  // bs3\n  SHOW: 'show' // bs4\n\n};\n/** @type {?} */\n\nconst TRANSITION_DURATIONS = {\n  MODAL: 300,\n  BACKDROP: 150\n};\n/** @type {?} */\n\nconst DISMISS_REASONS = {\n  BACKRDOP: 'backdrop-click',\n  ESC: 'esc'\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nlet ModalContainerComponent = /*#__PURE__*/(() => {\n  class ModalContainerComponent {\n    /**\n     * @param {?} options\n     * @param {?} _element\n     * @param {?} _renderer\n     */\n    constructor(options, _element, _renderer) {\n      this._element = _element;\n      this._renderer = _renderer;\n      this.isShown = false;\n      this.isModalHiding = false;\n      this.config = Object.assign({}, options);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.isAnimated) {\n        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.FADE);\n      }\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n\n      setTimeout(() => {\n        this.isShown = true;\n\n        this._renderer.addClass(this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);\n      }, this.isAnimated ? TRANSITION_DURATIONS.BACKDROP : 0);\n\n      if (document && document.body) {\n        if (this.bsModalService.getModalsCount() === 1) {\n          this.bsModalService.checkScrollbar();\n          this.bsModalService.setScrollbar();\n        }\n\n        this._renderer.addClass(document.body, CLASS_NAME.OPEN);\n      }\n\n      if (this._element.nativeElement) {\n        this._element.nativeElement.focus();\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onClick(event) {\n      if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || event.target !== this._element.nativeElement) {\n        return;\n      }\n\n      this.bsModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);\n      this.hide();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onEsc(event) {\n      if (!this.isShown) {\n        return;\n      } // tslint:disable-next-line:deprecation\n\n\n      if (event.keyCode === 27 || event.key === 'Escape') {\n        event.preventDefault();\n      }\n\n      if (this.config.keyboard && this.level === this.bsModalService.getModalsCount()) {\n        this.bsModalService.setDismissReason(DISMISS_REASONS.ESC);\n        this.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.isShown) {\n        this.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    hide() {\n      if (this.isModalHiding || !this.isShown) {\n        return;\n      }\n\n      this.isModalHiding = true;\n\n      this._renderer.removeClass(this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);\n\n      setTimeout(() => {\n        this.isShown = false;\n\n        if (document && document.body && this.bsModalService.getModalsCount() === 1) {\n          this._renderer.removeClass(document.body, CLASS_NAME.OPEN);\n        }\n\n        this.bsModalService.hide(this.level);\n        this.isModalHiding = false;\n      }, this.isAnimated ? TRANSITION_DURATIONS.MODAL : 0);\n    }\n\n  }\n\n  ModalContainerComponent.ɵfac = function ModalContainerComponent_Factory(t) {\n    return new (t || ModalContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ModalOptions), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  ModalContainerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ModalContainerComponent,\n    selectors: [[\"modal-container\"]],\n    hostAttrs: [\"role\", \"dialog\", \"tabindex\", \"-1\", 1, \"modal\"],\n    hostVars: 1,\n    hostBindings: function ModalContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ModalContainerComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"keydown.esc\", function ModalContainerComponent_keydown_esc_HostBindingHandler($event) {\n          return ctx.onEsc($event);\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-modal\", true);\n      }\n    },\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 2,\n    consts: [[\"role\", \"document\"], [1, \"modal-content\"]],\n    template: function ModalContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMap(\"modal-dialog\" + (ctx.config.class ? \" \" + ctx.config.class : \"\"));\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return ModalContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * This component will be added as background layout for modals if enabled\n */\n\n\nlet ModalBackdropComponent = /*#__PURE__*/(() => {\n  class ModalBackdropComponent {\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     */\n    constructor(element, renderer) {\n      this._isShown = false;\n      this.element = element;\n      this.renderer = renderer;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isAnimated() {\n      return this._isAnimated;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set isAnimated(value) {\n      this._isAnimated = value; // this.renderer.setElementClass(this.element.nativeElement, `${ClassName.FADE}`, value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isShown() {\n      return this._isShown;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set isShown(value) {\n      this._isShown = value;\n\n      if (value) {\n        this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.IN}`);\n      } else {\n        this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.IN}`);\n      }\n\n      if (!isBs3()) {\n        if (value) {\n          this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);\n        } else {\n          this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.isAnimated) {\n        this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.FADE}`);\n        Utils.reflow(this.element.nativeElement);\n      }\n\n      this.isShown = true;\n    }\n\n  }\n\n  ModalBackdropComponent.ɵfac = function ModalBackdropComponent_Factory(t) {\n    return new (t || ModalBackdropComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  ModalBackdropComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ModalBackdropComponent,\n    selectors: [[\"bs-modal-backdrop\"]],\n    hostAttrs: [1, \"modal-backdrop\"],\n    decls: 0,\n    vars: 0,\n    template: function ModalBackdropComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return ModalBackdropComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst TRANSITION_DURATION = 300;\n/** @type {?} */\n\nconst BACKDROP_TRANSITION_DURATION = 150;\n/**\n * Mark any code with directive to show it's content in modal\n */\n\nlet ModalDirective = /*#__PURE__*/(() => {\n  class ModalDirective {\n    /**\n     * @param {?} _element\n     * @param {?} _viewContainerRef\n     * @param {?} _renderer\n     * @param {?} clf\n     */\n    constructor(_element, _viewContainerRef, _renderer, clf) {\n      this._element = _element;\n      this._renderer = _renderer;\n      /**\n       * This event fires immediately when the `show` instance method is called.\n       */\n\n      this.onShow = new EventEmitter();\n      /**\n       * This event is fired when the modal has been made visible to the user\n       * (will wait for CSS transitions to complete)\n       */\n\n      this.onShown = new EventEmitter();\n      /**\n       * This event is fired immediately when\n       * the hide instance method has been called.\n       */\n\n      this.onHide = new EventEmitter();\n      /**\n       * This event is fired when the modal has finished being\n       * hidden from the user (will wait for CSS transitions to complete).\n       */\n\n      this.onHidden = new EventEmitter();\n      this._isShown = false;\n      this.isBodyOverflowing = false;\n      this.originalBodyPadding = 0;\n      this.scrollbarWidth = 0;\n      this.timerHideModal = 0;\n      this.timerRmBackDrop = 0;\n      this.isNested = false;\n      this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);\n    }\n    /**\n     * allows to set modal configuration via element property\n     * @param {?} conf\n     * @return {?}\n     */\n\n\n    set config(conf) {\n      this._config = this.getConfig(conf);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get config() {\n      return this._config;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isShown() {\n      return this._isShown;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onClick(event) {\n      if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || event.target !== this._element.nativeElement) {\n        return;\n      }\n\n      this.dismissReason = DISMISS_REASONS.BACKRDOP;\n      this.hide(event);\n    } // todo: consider preventing default and stopping propagation\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onEsc(event) {\n      if (!this._isShown) {\n        return;\n      } // tslint:disable-next-line:deprecation\n\n\n      if (event.keyCode === 27 || event.key === 'Escape') {\n        event.preventDefault();\n      }\n\n      if (this.config.keyboard) {\n        this.dismissReason = DISMISS_REASONS.ESC;\n        this.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.config = void 0;\n\n      if (this._isShown) {\n        this._isShown = false;\n        this.hideModal();\n\n        this._backdrop.dispose();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this._config = this._config || this.getConfig();\n      setTimeout(() => {\n        if (this._config.show) {\n          this.show();\n        }\n      }, 0);\n    }\n    /* Public methods */\n\n    /**\n     * Allows to manually toggle modal visibility\n     * @return {?}\n     */\n\n\n    toggle() {\n      return this._isShown ? this.hide() : this.show();\n    }\n    /**\n     * Allows to manually open modal\n     * @return {?}\n     */\n\n\n    show() {\n      this.dismissReason = null;\n      this.onShow.emit(this);\n\n      if (this._isShown) {\n        return;\n      }\n\n      clearTimeout(this.timerHideModal);\n      clearTimeout(this.timerRmBackDrop);\n      this._isShown = true;\n      this.checkScrollbar();\n      this.setScrollbar();\n\n      if (document$1 && document$1.body) {\n        if (document$1.body.classList.contains(CLASS_NAME.OPEN)) {\n          this.isNested = true;\n        } else {\n          this._renderer.addClass(document$1.body, CLASS_NAME.OPEN);\n        }\n      }\n\n      this.showBackdrop(() => {\n        this.showElement();\n      });\n    }\n    /**\n     * Allows to manually close modal\n     * @param {?=} event\n     * @return {?}\n     */\n\n\n    hide(event) {\n      if (event) {\n        event.preventDefault();\n      }\n\n      this.onHide.emit(this); // todo: add an option to prevent hiding\n\n      if (!this._isShown) {\n        return;\n      }\n\n      window$1.clearTimeout(this.timerHideModal);\n      window$1.clearTimeout(this.timerRmBackDrop);\n      this._isShown = false;\n\n      this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);\n\n      if (!isBs3()) {\n        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);\n      } // this._addClassIn = false;\n\n\n      if (this._config.animated) {\n        this.timerHideModal = window$1.setTimeout(() => this.hideModal(), TRANSITION_DURATION);\n      } else {\n        this.hideModal();\n      }\n    }\n    /**\n     * Private methods \\@internal\n     * @protected\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    getConfig(config) {\n      return Object.assign({}, modalConfigDefaults, config);\n    }\n    /**\n     *  Show dialog\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    showElement() {\n      // todo: replace this with component loader usage\n      if (!this._element.nativeElement.parentNode || this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // don't move modals dom position\n        if (document$1 && document$1.body) {\n          document$1.body.appendChild(this._element.nativeElement);\n        }\n      }\n\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'block');\n\n      this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);\n\n      if (this._config.animated) {\n        Utils.reflow(this._element.nativeElement);\n      } // this._addClassIn = true;\n\n\n      this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);\n\n      if (!isBs3()) {\n        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);\n      }\n      /** @type {?} */\n\n\n      const transitionComplete = () => {\n        if (this._config.focus) {\n          this._element.nativeElement.focus();\n        }\n\n        this.onShown.emit(this);\n      };\n\n      if (this._config.animated) {\n        setTimeout(transitionComplete, TRANSITION_DURATION);\n      } else {\n        transitionComplete();\n      }\n    }\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    hideModal() {\n      this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n\n      this._renderer.setStyle(this._element.nativeElement, 'display', 'none');\n\n      this.showBackdrop(() => {\n        if (!this.isNested) {\n          if (document$1 && document$1.body) {\n            this._renderer.removeClass(document$1.body, CLASS_NAME.OPEN);\n          }\n\n          this.resetScrollbar();\n        }\n\n        this.resetAdjustments();\n        this.focusOtherModal();\n        this.onHidden.emit(this);\n      });\n    } // todo: original show was calling a callback when done, but we can use\n    // promise\n\n    /**\n     * \\@internal\n     * @protected\n     * @param {?=} callback\n     * @return {?}\n     */\n\n\n    showBackdrop(callback) {\n      if (this._isShown && this.config.backdrop && (!this.backdrop || !this.backdrop.instance.isShown)) {\n        this.removeBackdrop();\n\n        this._backdrop.attach(ModalBackdropComponent).to('body').show({\n          isAnimated: this._config.animated\n        });\n\n        this.backdrop = this._backdrop._componentRef;\n\n        if (!callback) {\n          return;\n        }\n\n        if (!this._config.animated) {\n          callback();\n          return;\n        }\n\n        setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n      } else if (!this._isShown && this.backdrop) {\n        this.backdrop.instance.isShown = false;\n        /** @type {?} */\n\n        const callbackRemove = () => {\n          this.removeBackdrop();\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        if (this.backdrop.instance.isAnimated) {\n          this.timerRmBackDrop = window$1.setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    }\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    removeBackdrop() {\n      this._backdrop.hide();\n    }\n    /**\n     * Events tricks\n     * @protected\n     * @return {?}\n     */\n    // no need for it\n    // protected setEscapeEvent():void {\n    //   if (this._isShown && this._config.keyboard) {\n    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {\n    //       if (event.which === 27) {\n    //         this.hide()\n    //       }\n    //     })\n    //\n    //   } else if (!this._isShown) {\n    //     $(this._element).off(Event.KEYDOWN_DISMISS)\n    //   }\n    // }\n    // protected setResizeEvent():void {\n    // console.log(this.renderer.listenGlobal('', Event.RESIZE));\n    // if (this._isShown) {\n    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))\n    // } else {\n    //   $(window).off(Event.RESIZE)\n    // }\n    // }\n\n\n    focusOtherModal() {\n      if (this._element.nativeElement.parentElement == null) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');\n\n      if (!otherOpenedModals.length) {\n        return;\n      }\n\n      otherOpenedModals[otherOpenedModals.length - 1].focus();\n    }\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    resetAdjustments() {\n      this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');\n\n      this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');\n    }\n    /** Scroll bar tricks */\n\n    /**\n     * \\@internal\n     * @protected\n     * @return {?}\n     */\n\n\n    checkScrollbar() {\n      this.isBodyOverflowing = document$1.body.clientWidth < window$1.innerWidth;\n      this.scrollbarWidth = this.getScrollbarWidth();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    setScrollbar() {\n      if (!document$1) {\n        return;\n      }\n\n      this.originalBodyPadding = parseInt(window$1.getComputedStyle(document$1.body).getPropertyValue('padding-right') || 0, 10);\n\n      if (this.isBodyOverflowing) {\n        document$1.body.style.paddingRight = `${this.originalBodyPadding + this.scrollbarWidth}px`;\n      }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    resetScrollbar() {\n      document$1.body.style.paddingRight = `${this.originalBodyPadding}px`;\n    } // thx d.walsh\n\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    getScrollbarWidth() {\n      /** @type {?} */\n      const scrollDiv = this._renderer.createElement('div');\n\n      this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);\n\n      this._renderer.appendChild(document$1.body, scrollDiv);\n      /** @type {?} */\n\n\n      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n      this._renderer.removeChild(document$1.body, scrollDiv);\n\n      return scrollbarWidth;\n    }\n\n  }\n\n  ModalDirective.ɵfac = function ModalDirective_Factory(t) {\n    return new (t || ModalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ComponentLoaderFactory));\n  };\n\n  ModalDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ModalDirective,\n    selectors: [[\"\", \"bsModal\", \"\"]],\n    hostBindings: function ModalDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ModalDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"keydown.esc\", function ModalDirective_keydown_esc_HostBindingHandler($event) {\n          return ctx.onEsc($event);\n        });\n      }\n    },\n    inputs: {\n      config: \"config\"\n    },\n    outputs: {\n      onShow: \"onShow\",\n      onShown: \"onShown\",\n      onHide: \"onHide\",\n      onHidden: \"onHidden\"\n    },\n    exportAs: [\"bs-modal\"]\n  });\n  /** @nocollapse */\n\n  return ModalDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet BsModalService = /*#__PURE__*/(() => {\n  class BsModalService {\n    /**\n     * @param {?} rendererFactory\n     * @param {?} clf\n     */\n    constructor(rendererFactory, clf) {\n      this.clf = clf; // constructor props\n\n      this.config = modalConfigDefaults; // tslint:disable-next-line:no-any\n\n      this.onShow = new EventEmitter(); // tslint:disable-next-line:no-any\n\n      this.onShown = new EventEmitter(); // tslint:disable-next-line:no-any\n\n      this.onHide = new EventEmitter(); // tslint:disable-next-line:no-any\n\n      this.onHidden = new EventEmitter();\n      this.isBodyOverflowing = false;\n      this.originalBodyPadding = 0;\n      this.scrollbarWidth = 0;\n      this.modalsCount = 0;\n      this.lastDismissReason = '';\n      this.loaders = [];\n      this._backdropLoader = this.clf.createLoader(null, null, null);\n      this._renderer = rendererFactory.createRenderer(null, null);\n    }\n    /**\n     * Shows a modal\n     * @param {?} content\n     * @param {?=} config\n     * @return {?}\n     */\n    // tslint:disable-next-line:no-any\n\n\n    show(content, config) {\n      this.modalsCount++;\n\n      this._createLoaders();\n\n      this.config = Object.assign({}, modalConfigDefaults, config);\n\n      this._showBackdrop();\n\n      this.lastDismissReason = null;\n      return this._showModal(content);\n    }\n    /**\n     * @param {?} level\n     * @return {?}\n     */\n\n\n    hide(level) {\n      if (this.modalsCount === 1) {\n        this._hideBackdrop();\n\n        this.resetScrollbar();\n      }\n\n      this.modalsCount = this.modalsCount >= 1 ? this.modalsCount - 1 : 0;\n      setTimeout(() => {\n        this._hideModal(level);\n\n        this.removeLoaders(level);\n      }, this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _showBackdrop() {\n      /** @type {?} */\n      const isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';\n      /** @type {?} */\n\n      const isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;\n\n      if (this.modalsCount === 1) {\n        this.removeBackdrop();\n\n        if (isBackdropEnabled && isBackdropInDOM) {\n          this._backdropLoader.attach(ModalBackdropComponent).to('body').show({\n            isAnimated: this.config.animated\n          });\n\n          this.backdropRef = this._backdropLoader._componentRef;\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _hideBackdrop() {\n      if (!this.backdropRef) {\n        return;\n      }\n\n      this.backdropRef.instance.isShown = false;\n      /** @type {?} */\n\n      const duration = this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0;\n      setTimeout(() => this.removeBackdrop(), duration);\n    } // tslint:disable-next-line:no-any\n\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n\n\n    _showModal(content) {\n      /** @type {?} */\n      const modalLoader = this.loaders[this.loaders.length - 1];\n      /** @type {?} */\n\n      const bsModalRef = new BsModalRef();\n      /** @type {?} */\n\n      const modalContainerRef = modalLoader.provide({\n        provide: ModalOptions,\n        useValue: this.config\n      }).provide({\n        provide: BsModalRef,\n        useValue: bsModalRef\n      }).attach(ModalContainerComponent).to('body').show({\n        content,\n        isAnimated: this.config.animated,\n        initialState: this.config.initialState,\n        bsModalService: this\n      });\n      modalContainerRef.instance.level = this.getModalsCount();\n\n      bsModalRef.hide = () => {\n        modalContainerRef.instance.hide();\n      };\n\n      bsModalRef.content = modalLoader.getInnerComponent() || null;\n\n      bsModalRef.setClass = newClass => {\n        modalContainerRef.instance.config.class = newClass;\n      };\n\n      return bsModalRef;\n    }\n    /**\n     * @param {?} level\n     * @return {?}\n     */\n\n\n    _hideModal(level) {\n      /** @type {?} */\n      const modalLoader = this.loaders[level - 1];\n\n      if (modalLoader) {\n        modalLoader.hide();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getModalsCount() {\n      return this.modalsCount;\n    }\n    /**\n     * @param {?} reason\n     * @return {?}\n     */\n\n\n    setDismissReason(reason) {\n      this.lastDismissReason = reason;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    removeBackdrop() {\n      this._backdropLoader.hide();\n\n      this.backdropRef = null;\n    }\n    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */\n\n    /** Scroll bar tricks */\n\n    /**\n     * \\@internal\n     * @return {?}\n     */\n\n\n    checkScrollbar() {\n      this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n      this.scrollbarWidth = this.getScrollbarWidth();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    setScrollbar() {\n      if (!document) {\n        return;\n      }\n\n      this.originalBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right') || '0', 10);\n\n      if (this.isBodyOverflowing) {\n        document.body.style.paddingRight = `${this.originalBodyPadding + this.scrollbarWidth}px`;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    resetScrollbar() {\n      document.body.style.paddingRight = `${this.originalBodyPadding}px`;\n    } // thx d.walsh\n\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getScrollbarWidth() {\n      /** @type {?} */\n      const scrollDiv = this._renderer.createElement('div');\n\n      this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);\n\n      this._renderer.appendChild(document.body, scrollDiv);\n      /** @type {?} */\n\n\n      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n      this._renderer.removeChild(document.body, scrollDiv);\n\n      return scrollbarWidth;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _createLoaders() {\n      /** @type {?} */\n      const loader = this.clf.createLoader(null, null, null);\n      this.copyEvent(loader.onBeforeShow, this.onShow);\n      this.copyEvent(loader.onShown, this.onShown);\n      this.copyEvent(loader.onBeforeHide, this.onHide);\n      this.copyEvent(loader.onHidden, this.onHidden);\n      this.loaders.push(loader);\n    }\n    /**\n     * @private\n     * @param {?} level\n     * @return {?}\n     */\n\n\n    removeLoaders(level) {\n      this.loaders.splice(level - 1, 1);\n      this.loaders.forEach((loader, i) => {\n        loader.instance.level = i + 1;\n      });\n    } // tslint:disable-next-line:no-any\n\n    /**\n     * @private\n     * @param {?} from\n     * @param {?} to\n     * @return {?}\n     */\n\n\n    copyEvent(from, to) {\n      from.subscribe(() => {\n        to.emit(this.lastDismissReason);\n      });\n    }\n\n  }\n\n  BsModalService.ɵfac = function BsModalService_Factory(t) {\n    return new (t || BsModalService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(ɵngcc1.ComponentLoaderFactory));\n  };\n\n  BsModalService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: BsModalService,\n    factory: BsModalService.ɵfac\n  });\n  /** @nocollapse */\n\n  return BsModalService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ModalModule = /*#__PURE__*/(() => {\n  class ModalModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n      return {\n        ngModule: ModalModule,\n        providers: [BsModalService, ComponentLoaderFactory, PositioningService]\n      };\n    }\n\n  }\n\n  ModalModule.ɵfac = function ModalModule_Factory(t) {\n    return new (t || ModalModule)();\n  };\n\n  ModalModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ModalModule\n  });\n  ModalModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return ModalModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ModalModule, {\n    declarations: [ModalBackdropComponent, ModalDirective, ModalContainerComponent],\n    exports: [ModalBackdropComponent, ModalDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { BsModalRef, ModalBackdropOptions, ModalContainerComponent, ModalBackdropComponent, ModalOptions, ModalDirective, ModalModule, BsModalService, CLASS_NAME as ɵa }; //# sourceMappingURL=ngx-bootstrap-modal.js.map","map":null,"metadata":{},"sourceType":"module"}