{"hash":"4e0f1e524ee626a355b16f18c13ab6fd1773f6b5","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, EventEmitter, Directive, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport Sortable from 'sortablejs';\n\nconst GLOBALS = new InjectionToken('Global config for sortablejs');\n\nclass SortablejsBinding {\n    constructor(target) {\n        this.target = target;\n    }\n    insert(index, item) {\n        if (this.isFormArray) {\n            this.target.insert(index, item);\n        }\n        else {\n            this.target.splice(index, 0, item);\n        }\n    }\n    get(index) {\n        return this.isFormArray ? this.target.at(index) : this.target[index];\n    }\n    remove(index) {\n        let item;\n        if (this.isFormArray) {\n            item = this.target.at(index);\n            this.target.removeAt(index);\n        }\n        else {\n            item = this.target.splice(index, 1)[0];\n        }\n        return item;\n    }\n    // we need this to identify that the target is a FormArray\n    // we don't want to have a dependency on @angular/forms just for that\n    get isFormArray() {\n        // just checking for random FormArray methods not available on a standard array\n        return !!this.target.at && !!this.target.insert && !!this.target.reset;\n    }\n}\n\nclass SortablejsBindings {\n    constructor(bindingTargets) {\n        this.bindings = bindingTargets.map(target => new SortablejsBinding(target));\n    }\n    injectIntoEvery(index, items) {\n        this.bindings.forEach((b, i) => b.insert(index, items[i]));\n    }\n    getFromEvery(index) {\n        return this.bindings.map(b => b.get(index));\n    }\n    extractFromEvery(index) {\n        return this.bindings.map(b => b.remove(index));\n    }\n    get provided() {\n        return !!this.bindings.length;\n    }\n}\n\nclass SortablejsService {\n}\n/** @nocollapse */ SortablejsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ SortablejsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\n\nconst getIndexesFromEvent = (event) => {\n    if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {\n        return {\n            new: event.newDraggableIndex,\n            old: event.oldDraggableIndex,\n        };\n    }\n    else {\n        return {\n            new: event.newIndex,\n            old: event.oldIndex,\n        };\n    }\n};\nclass SortablejsDirective {\n    constructor(globalConfig, service, element, zone, renderer) {\n        this.globalConfig = globalConfig;\n        this.service = service;\n        this.element = element;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.sortablejsInit = new EventEmitter();\n    }\n    ngOnInit() {\n        if (Sortable && Sortable.create) { // Sortable does not exist in angular universal (SSR)\n            this.create();\n        }\n    }\n    ngOnChanges(changes) {\n        const optionsChange = changes.sortablejsOptions;\n        if (optionsChange && !optionsChange.isFirstChange()) {\n            const previousOptions = optionsChange.previousValue;\n            const currentOptions = optionsChange.currentValue;\n            Object.keys(currentOptions).forEach(optionName => {\n                if (currentOptions[optionName] !== previousOptions[optionName]) {\n                    // use low-level option setter\n                    this.sortableInstance.option(optionName, this.options[optionName]);\n                }\n            });\n        }\n    }\n    ngOnDestroy() {\n        if (this.sortableInstance) {\n            this.sortableInstance.destroy();\n        }\n    }\n    create() {\n        const container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;\n        setTimeout(() => {\n            this.sortableInstance = Sortable.create(container, this.options);\n            this.sortablejsInit.emit(this.sortableInstance);\n        }, 0);\n    }\n    getBindings() {\n        if (!this.sortablejs) {\n            return new SortablejsBindings([]);\n        }\n        else if (this.sortablejs instanceof SortablejsBindings) {\n            return this.sortablejs;\n        }\n        else {\n            return new SortablejsBindings([this.sortablejs]);\n        }\n    }\n    get options() {\n        return { ...this.optionsWithoutEvents, ...this.overridenOptions };\n    }\n    get optionsWithoutEvents() {\n        return { ...(this.globalConfig || {}), ...(this.sortablejsOptions || {}) };\n    }\n    proxyEvent(eventName, ...params) {\n        this.zone.run(() => {\n            if (this.optionsWithoutEvents && this.optionsWithoutEvents[eventName]) {\n                this.optionsWithoutEvents[eventName](...params);\n            }\n        });\n    }\n    get isCloning() {\n        return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';\n    }\n    clone(item) {\n        // by default pass the item through, no cloning performed\n        return (this.sortablejsCloneFunction || (subitem => subitem))(item);\n    }\n    get overridenOptions() {\n        // always intercept standard events but act only in case items are set (bindingEnabled)\n        // allows to forget about tracking this.items changes\n        return {\n            onAdd: (event) => {\n                this.service.transfer = (items) => {\n                    this.getBindings().injectIntoEvery(event.newIndex, items);\n                    this.proxyEvent('onAdd', event);\n                };\n                this.proxyEvent('onAddOriginal', event);\n            },\n            onRemove: (event) => {\n                const bindings = this.getBindings();\n                if (bindings.provided) {\n                    if (this.isCloning) {\n                        this.service.transfer(bindings.getFromEvery(event.oldIndex).map(item => this.clone(item)));\n                        // great thanks to https://github.com/tauu\n                        // event.item is the original item from the source list which is moved to the target list\n                        // event.clone is a clone of the original item and will be added to source list\n                        // If bindings are provided, adding the item dom element to the target list causes artifacts\n                        // as it interferes with the rendering performed by the angular template.\n                        // Therefore we remove it immediately and also move the original item back to the source list.\n                        // (event handler may be attached to the original item and not its clone, therefore keeping\n                        // the original dom node, circumvents side effects )\n                        this.renderer.removeChild(event.item.parentNode, event.item);\n                        this.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);\n                        this.renderer.removeChild(event.clone.parentNode, event.clone);\n                    }\n                    else {\n                        this.service.transfer(bindings.extractFromEvery(event.oldIndex));\n                    }\n                    this.service.transfer = null;\n                }\n                this.proxyEvent('onRemove', event);\n            },\n            onUpdate: (event) => {\n                const bindings = this.getBindings();\n                const indexes = getIndexesFromEvent(event);\n                bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));\n                this.proxyEvent('onUpdate', event);\n            },\n        };\n    }\n}\n/** @nocollapse */ SortablejsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsDirective, deps: [{ token: GLOBALS, optional: true }, { token: SortablejsService }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });\n/** @nocollapse */ SortablejsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.11\", type: SortablejsDirective, selector: \"[sortablejs]\", inputs: { sortablejs: \"sortablejs\", sortablejsContainer: \"sortablejsContainer\", sortablejsOptions: \"sortablejsOptions\", sortablejsCloneFunction: \"sortablejsCloneFunction\" }, outputs: { sortablejsInit: \"sortablejsInit\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[sortablejs]',\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [GLOBALS]\n                }] }, { type: SortablejsService }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }]; }, propDecorators: { sortablejs: [{\n                type: Input\n            }], sortablejsContainer: [{\n                type: Input\n            }], sortablejsOptions: [{\n                type: Input\n            }], sortablejsCloneFunction: [{\n                type: Input\n            }], sortablejsInit: [{\n                type: Output\n            }] } });\n\nclass SortablejsModule {\n    static forRoot(globalOptions) {\n        return {\n            ngModule: SortablejsModule,\n            providers: [\n                { provide: GLOBALS, useValue: globalOptions },\n            ],\n        };\n    }\n}\n/** @nocollapse */ SortablejsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ SortablejsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule, declarations: [SortablejsDirective], exports: [SortablejsDirective] });\n/** @nocollapse */ SortablejsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [SortablejsDirective],\n                    exports: [SortablejsDirective],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SortablejsDirective, SortablejsModule };\n//# sourceMappingURL=ngx-sortablejs.mjs.map\n","map":{"version":3,"file":"ngx-sortablejs.mjs","sources":["../../../projects/ngx-sortablejs/src/lib/globals.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs-binding.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs-bindings.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs.service.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs.directive.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs.module.ts","../../../projects/ngx-sortablejs/src/ngx-sortablejs.ts"],"sourcesContent":["import {InjectionToken} from '@angular/core';\nimport {Options} from 'sortablejs';\n\nexport const GLOBALS: InjectionToken<Options> = new InjectionToken('Global config for sortablejs');\n","import {SortableData} from './sortablejs.directive';\n\nexport class SortablejsBinding {\n\n  constructor(private target: SortableData) {\n  }\n\n  insert(index: number, item: any) {\n    if (this.isFormArray) {\n      this.target.insert(index, item);\n    } else {\n      this.target.splice(index, 0, item);\n    }\n  }\n\n  get(index: number) {\n    return this.isFormArray ? this.target.at(index) : this.target[index];\n  }\n\n  remove(index: number) {\n    let item;\n\n    if (this.isFormArray) {\n      item = this.target.at(index);\n      this.target.removeAt(index);\n    } else {\n      item = this.target.splice(index, 1)[0];\n    }\n\n    return item;\n  }\n\n  // we need this to identify that the target is a FormArray\n  // we don't want to have a dependency on @angular/forms just for that\n  private get isFormArray() {\n    // just checking for random FormArray methods not available on a standard array\n    return !!this.target.at && !!this.target.insert && !!this.target.reset;\n  }\n\n}\n","import { SortablejsBinding } from './sortablejs-binding';\nimport {SortableData} from './sortablejs.directive';\n\nexport class SortablejsBindings {\n\n  bindings: SortablejsBinding[];\n\n  constructor(bindingTargets: SortableData[]) {\n    this.bindings = bindingTargets.map(target => new SortablejsBinding(target));\n  }\n\n  injectIntoEvery(index: number, items: any[]) {\n    this.bindings.forEach((b, i) => b.insert(index, items[i]));\n  }\n\n  getFromEvery(index: number) {\n    return this.bindings.map(b => b.get(index));\n  }\n\n  extractFromEvery(index: number) {\n    return this.bindings.map(b => b.remove(index));\n  }\n\n  get provided() {\n    return !!this.bindings.length;\n  }\n\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SortablejsService {\n\n  // original library calls the events in unnatural order\n  // first the item is added, then removed from the previous array\n  // this is a temporary event to work this around\n  // as long as only one sortable takes place at a certain time\n  // this is enough to have a single `global` event\n  transfer: (items: any[]) => void;\n\n}\n","import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  Renderer2,\n  SimpleChange,\n} from '@angular/core';\nimport Sortable, {Options} from 'sortablejs';\nimport {GLOBALS} from './globals';\nimport {SortablejsBindings} from './sortablejs-bindings';\nimport {SortablejsService} from './sortablejs.service';\n\nexport type SortableData = any | any[];\n\nconst getIndexesFromEvent = (event: SortableEvent) => {\n  if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {\n    return {\n      new: event.newDraggableIndex,\n      old: event.oldDraggableIndex,\n    };\n  } else {\n    return {\n      new: event.newIndex,\n      old: event.oldIndex,\n    };\n  }\n};\n\n@Directive({\n  selector: '[sortablejs]',\n})\nexport class SortablejsDirective implements OnInit, OnChanges, OnDestroy {\n\n  @Input()\n  sortablejs: SortableData; // array or a FormArray\n\n  @Input()\n  sortablejsContainer: string;\n\n  @Input()\n  sortablejsOptions: Options;\n\n  @Input()\n  sortablejsCloneFunction: (item: any) => any;\n\n  private sortableInstance: any;\n\n  @Output() sortablejsInit = new EventEmitter();\n\n  constructor(\n    @Optional() @Inject(GLOBALS) private globalConfig: Options,\n    private service: SortablejsService,\n    private element: ElementRef,\n    private zone: NgZone,\n    private renderer: Renderer2,\n  ) {\n  }\n\n  ngOnInit() {\n    if (Sortable && Sortable.create) { // Sortable does not exist in angular universal (SSR)\n      this.create();\n    }\n  }\n\n  ngOnChanges(changes: { [prop in keyof SortablejsDirective]: SimpleChange }) {\n    const optionsChange: SimpleChange = changes.sortablejsOptions;\n\n    if (optionsChange && !optionsChange.isFirstChange()) {\n      const previousOptions: Options = optionsChange.previousValue;\n      const currentOptions: Options = optionsChange.currentValue;\n\n      Object.keys(currentOptions).forEach(optionName => {\n        if (currentOptions[optionName] !== previousOptions[optionName]) {\n          // use low-level option setter\n          this.sortableInstance.option(optionName, this.options[optionName]);\n        }\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.sortableInstance) {\n      this.sortableInstance.destroy();\n    }\n  }\n\n  private create() {\n    const container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;\n\n    setTimeout(() => {\n      this.sortableInstance = Sortable.create(container, this.options);\n      this.sortablejsInit.emit(this.sortableInstance);\n    }, 0);\n  }\n\n  private getBindings(): SortablejsBindings {\n    if (!this.sortablejs) {\n      return new SortablejsBindings([]);\n    } else if (this.sortablejs instanceof SortablejsBindings) {\n      return this.sortablejs;\n    } else {\n      return new SortablejsBindings([this.sortablejs]);\n    }\n  }\n\n  private get options() {\n    return {...this.optionsWithoutEvents, ...this.overridenOptions};\n  }\n\n  private get optionsWithoutEvents() {\n    return {...(this.globalConfig || {}), ...(this.sortablejsOptions || {})};\n  }\n\n  private proxyEvent(eventName: string, ...params: any[]) {\n    this.zone.run(() => { // re-entering zone, see https://github.com/SortableJS/angular-sortablejs/issues/110#issuecomment-408874600\n      if (this.optionsWithoutEvents && this.optionsWithoutEvents[eventName]) {\n        this.optionsWithoutEvents[eventName](...params);\n      }\n    });\n  }\n\n  private get isCloning() {\n    return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';\n  }\n\n  private clone<T>(item: T): T {\n    // by default pass the item through, no cloning performed\n    return (this.sortablejsCloneFunction || (subitem => subitem))(item);\n  }\n\n  private get overridenOptions(): Options {\n    // always intercept standard events but act only in case items are set (bindingEnabled)\n    // allows to forget about tracking this.items changes\n    return {\n      onAdd: (event: SortableEvent) => {\n        this.service.transfer = (items: any[]) => {\n          this.getBindings().injectIntoEvery(event.newIndex, items);\n          this.proxyEvent('onAdd', event);\n        };\n\n        this.proxyEvent('onAddOriginal', event);\n      },\n      onRemove: (event: SortableEvent) => {\n        const bindings = this.getBindings();\n\n        if (bindings.provided) {\n          if (this.isCloning) {\n            this.service.transfer(bindings.getFromEvery(event.oldIndex).map(item => this.clone(item)));\n\n            // great thanks to https://github.com/tauu\n            // event.item is the original item from the source list which is moved to the target list\n            // event.clone is a clone of the original item and will be added to source list\n            // If bindings are provided, adding the item dom element to the target list causes artifacts\n            // as it interferes with the rendering performed by the angular template.\n            // Therefore we remove it immediately and also move the original item back to the source list.\n            // (event handler may be attached to the original item and not its clone, therefore keeping\n            // the original dom node, circumvents side effects )\n            this.renderer.removeChild(event.item.parentNode, event.item);\n            this.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);\n            this.renderer.removeChild(event.clone.parentNode, event.clone);\n          } else {\n            this.service.transfer(bindings.extractFromEvery(event.oldIndex));\n          }\n\n          this.service.transfer = null;\n        }\n\n        this.proxyEvent('onRemove', event);\n      },\n      onUpdate: (event: SortableEvent) => {\n        const bindings = this.getBindings();\n        const indexes = getIndexesFromEvent(event);\n\n        bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));\n        this.proxyEvent('onUpdate', event);\n      },\n    };\n  }\n\n}\n\ninterface SortableEvent {\n  oldIndex: number;\n  newIndex: number;\n  oldDraggableIndex?: number;\n  newDraggableIndex?: number;\n  item: HTMLElement;\n  clone: HTMLElement;\n}\n","import {ModuleWithProviders, NgModule} from '@angular/core';\nimport {GLOBALS} from './globals';\nimport {SortablejsDirective} from './sortablejs.directive';\nimport {Options} from 'sortablejs';\n\n@NgModule({\n  declarations: [SortablejsDirective],\n  exports: [SortablejsDirective],\n})\nexport class SortablejsModule {\n\n  public static forRoot(globalOptions: Options): ModuleWithProviders<SortablejsModule> {\n    return {\n      ngModule: SortablejsModule,\n      providers: [\n        {provide: GLOBALS, useValue: globalOptions},\n      ],\n    };\n  }\n\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["i1.SortablejsService"],"mappings":"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"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, EventEmitter, Directive, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport Sortable from 'sortablejs';\n\nconst GLOBALS = new InjectionToken('Global config for sortablejs');\n\nclass SortablejsBinding {\n    constructor(target) {\n        this.target = target;\n    }\n    insert(index, item) {\n        if (this.isFormArray) {\n            this.target.insert(index, item);\n        }\n        else {\n            this.target.splice(index, 0, item);\n        }\n    }\n    get(index) {\n        return this.isFormArray ? this.target.at(index) : this.target[index];\n    }\n    remove(index) {\n        let item;\n        if (this.isFormArray) {\n            item = this.target.at(index);\n            this.target.removeAt(index);\n        }\n        else {\n            item = this.target.splice(index, 1)[0];\n        }\n        return item;\n    }\n    // we need this to identify that the target is a FormArray\n    // we don't want to have a dependency on @angular/forms just for that\n    get isFormArray() {\n        // just checking for random FormArray methods not available on a standard array\n        return !!this.target.at && !!this.target.insert && !!this.target.reset;\n    }\n}\n\nclass SortablejsBindings {\n    constructor(bindingTargets) {\n        this.bindings = bindingTargets.map(target => new SortablejsBinding(target));\n    }\n    injectIntoEvery(index, items) {\n        this.bindings.forEach((b, i) => b.insert(index, items[i]));\n    }\n    getFromEvery(index) {\n        return this.bindings.map(b => b.get(index));\n    }\n    extractFromEvery(index) {\n        return this.bindings.map(b => b.remove(index));\n    }\n    get provided() {\n        return !!this.bindings.length;\n    }\n}\n\nclass SortablejsService {\n}\n/** @nocollapse */ SortablejsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ SortablejsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\n\nconst getIndexesFromEvent = (event) => {\n    if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {\n        return {\n            new: event.newDraggableIndex,\n            old: event.oldDraggableIndex,\n        };\n    }\n    else {\n        return {\n            new: event.newIndex,\n            old: event.oldIndex,\n        };\n    }\n};\nclass SortablejsDirective {\n    constructor(globalConfig, service, element, zone, renderer) {\n        this.globalConfig = globalConfig;\n        this.service = service;\n        this.element = element;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.sortablejsInit = new EventEmitter();\n    }\n    ngOnInit() {\n        if (Sortable && Sortable.create) { // Sortable does not exist in angular universal (SSR)\n            this.create();\n        }\n    }\n    ngOnChanges(changes) {\n        const optionsChange = changes.sortablejsOptions;\n        if (optionsChange && !optionsChange.isFirstChange()) {\n            const previousOptions = optionsChange.previousValue;\n            const currentOptions = optionsChange.currentValue;\n            Object.keys(currentOptions).forEach(optionName => {\n                if (currentOptions[optionName] !== previousOptions[optionName]) {\n                    // use low-level option setter\n                    this.sortableInstance.option(optionName, this.options[optionName]);\n                }\n            });\n        }\n    }\n    ngOnDestroy() {\n        if (this.sortableInstance) {\n            this.sortableInstance.destroy();\n        }\n    }\n    create() {\n        const container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;\n        setTimeout(() => {\n            this.sortableInstance = Sortable.create(container, this.options);\n            this.sortablejsInit.emit(this.sortableInstance);\n        }, 0);\n    }\n    getBindings() {\n        if (!this.sortablejs) {\n            return new SortablejsBindings([]);\n        }\n        else if (this.sortablejs instanceof SortablejsBindings) {\n            return this.sortablejs;\n        }\n        else {\n            return new SortablejsBindings([this.sortablejs]);\n        }\n    }\n    get options() {\n        return Object.assign(Object.assign({}, this.optionsWithoutEvents), this.overridenOptions);\n    }\n    get optionsWithoutEvents() {\n        return Object.assign(Object.assign({}, (this.globalConfig || {})), (this.sortablejsOptions || {}));\n    }\n    proxyEvent(eventName, ...params) {\n        this.zone.run(() => {\n            if (this.optionsWithoutEvents && this.optionsWithoutEvents[eventName]) {\n                this.optionsWithoutEvents[eventName](...params);\n            }\n        });\n    }\n    get isCloning() {\n        return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';\n    }\n    clone(item) {\n        // by default pass the item through, no cloning performed\n        return (this.sortablejsCloneFunction || (subitem => subitem))(item);\n    }\n    get overridenOptions() {\n        // always intercept standard events but act only in case items are set (bindingEnabled)\n        // allows to forget about tracking this.items changes\n        return {\n            onAdd: (event) => {\n                this.service.transfer = (items) => {\n                    this.getBindings().injectIntoEvery(event.newIndex, items);\n                    this.proxyEvent('onAdd', event);\n                };\n                this.proxyEvent('onAddOriginal', event);\n            },\n            onRemove: (event) => {\n                const bindings = this.getBindings();\n                if (bindings.provided) {\n                    if (this.isCloning) {\n                        this.service.transfer(bindings.getFromEvery(event.oldIndex).map(item => this.clone(item)));\n                        // great thanks to https://github.com/tauu\n                        // event.item is the original item from the source list which is moved to the target list\n                        // event.clone is a clone of the original item and will be added to source list\n                        // If bindings are provided, adding the item dom element to the target list causes artifacts\n                        // as it interferes with the rendering performed by the angular template.\n                        // Therefore we remove it immediately and also move the original item back to the source list.\n                        // (event handler may be attached to the original item and not its clone, therefore keeping\n                        // the original dom node, circumvents side effects )\n                        this.renderer.removeChild(event.item.parentNode, event.item);\n                        this.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);\n                        this.renderer.removeChild(event.clone.parentNode, event.clone);\n                    }\n                    else {\n                        this.service.transfer(bindings.extractFromEvery(event.oldIndex));\n                    }\n                    this.service.transfer = null;\n                }\n                this.proxyEvent('onRemove', event);\n            },\n            onUpdate: (event) => {\n                const bindings = this.getBindings();\n                const indexes = getIndexesFromEvent(event);\n                bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));\n                this.proxyEvent('onUpdate', event);\n            },\n        };\n    }\n}\n/** @nocollapse */ SortablejsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsDirective, deps: [{ token: GLOBALS, optional: true }, { token: SortablejsService }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });\n/** @nocollapse */ SortablejsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.11\", type: SortablejsDirective, selector: \"[sortablejs]\", inputs: { sortablejs: \"sortablejs\", sortablejsContainer: \"sortablejsContainer\", sortablejsOptions: \"sortablejsOptions\", sortablejsCloneFunction: \"sortablejsCloneFunction\" }, outputs: { sortablejsInit: \"sortablejsInit\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[sortablejs]',\n                }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [GLOBALS]\n                    }] }, { type: SortablejsService }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }];\n    }, propDecorators: { sortablejs: [{\n                type: Input\n            }], sortablejsContainer: [{\n                type: Input\n            }], sortablejsOptions: [{\n                type: Input\n            }], sortablejsCloneFunction: [{\n                type: Input\n            }], sortablejsInit: [{\n                type: Output\n            }] } });\n\nclass SortablejsModule {\n    static forRoot(globalOptions) {\n        return {\n            ngModule: SortablejsModule,\n            providers: [\n                { provide: GLOBALS, useValue: globalOptions },\n            ],\n        };\n    }\n}\n/** @nocollapse */ SortablejsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ SortablejsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule, declarations: [SortablejsDirective], exports: [SortablejsDirective] });\n/** @nocollapse */ SortablejsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.11\", ngImport: i0, type: SortablejsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [SortablejsDirective],\n                    exports: [SortablejsDirective],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SortablejsDirective, SortablejsModule };\n//# sourceMappingURL=ngx-sortablejs.mjs.map\n","map":{"version":3,"file":"ngx-sortablejs.mjs","sources":["../../../projects/ngx-sortablejs/src/lib/globals.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs-binding.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs-bindings.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs.service.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs.directive.ts","../../../projects/ngx-sortablejs/src/lib/sortablejs.module.ts","../../../projects/ngx-sortablejs/src/ngx-sortablejs.ts"],"sourcesContent":["import {InjectionToken} from '@angular/core';\nimport {Options} from 'sortablejs';\n\nexport const GLOBALS: InjectionToken<Options> = new InjectionToken('Global config for sortablejs');\n","import {SortableData} from './sortablejs.directive';\n\nexport class SortablejsBinding {\n\n  constructor(private target: SortableData) {\n  }\n\n  insert(index: number, item: any) {\n    if (this.isFormArray) {\n      this.target.insert(index, item);\n    } else {\n      this.target.splice(index, 0, item);\n    }\n  }\n\n  get(index: number) {\n    return this.isFormArray ? this.target.at(index) : this.target[index];\n  }\n\n  remove(index: number) {\n    let item;\n\n    if (this.isFormArray) {\n      item = this.target.at(index);\n      this.target.removeAt(index);\n    } else {\n      item = this.target.splice(index, 1)[0];\n    }\n\n    return item;\n  }\n\n  // we need this to identify that the target is a FormArray\n  // we don't want to have a dependency on @angular/forms just for that\n  private get isFormArray() {\n    // just checking for random FormArray methods not available on a standard array\n    return !!this.target.at && !!this.target.insert && !!this.target.reset;\n  }\n\n}\n","import { SortablejsBinding } from './sortablejs-binding';\nimport {SortableData} from './sortablejs.directive';\n\nexport class SortablejsBindings {\n\n  bindings: SortablejsBinding[];\n\n  constructor(bindingTargets: SortableData[]) {\n    this.bindings = bindingTargets.map(target => new SortablejsBinding(target));\n  }\n\n  injectIntoEvery(index: number, items: any[]) {\n    this.bindings.forEach((b, i) => b.insert(index, items[i]));\n  }\n\n  getFromEvery(index: number) {\n    return this.bindings.map(b => b.get(index));\n  }\n\n  extractFromEvery(index: number) {\n    return this.bindings.map(b => b.remove(index));\n  }\n\n  get provided() {\n    return !!this.bindings.length;\n  }\n\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SortablejsService {\n\n  // original library calls the events in unnatural order\n  // first the item is added, then removed from the previous array\n  // this is a temporary event to work this around\n  // as long as only one sortable takes place at a certain time\n  // this is enough to have a single `global` event\n  transfer: (items: any[]) => void;\n\n}\n","import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  Renderer2,\n  SimpleChange,\n} from '@angular/core';\nimport Sortable, {Options} from 'sortablejs';\nimport {GLOBALS} from './globals';\nimport {SortablejsBindings} from './sortablejs-bindings';\nimport {SortablejsService} from './sortablejs.service';\n\nexport type SortableData = any | any[];\n\nconst getIndexesFromEvent = (event: SortableEvent) => {\n  if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {\n    return {\n      new: event.newDraggableIndex,\n      old: event.oldDraggableIndex,\n    };\n  } else {\n    return {\n      new: event.newIndex,\n      old: event.oldIndex,\n    };\n  }\n};\n\n@Directive({\n  selector: '[sortablejs]',\n})\nexport class SortablejsDirective implements OnInit, OnChanges, OnDestroy {\n\n  @Input()\n  sortablejs: SortableData; // array or a FormArray\n\n  @Input()\n  sortablejsContainer: string;\n\n  @Input()\n  sortablejsOptions: Options;\n\n  @Input()\n  sortablejsCloneFunction: (item: any) => any;\n\n  private sortableInstance: any;\n\n  @Output() sortablejsInit = new EventEmitter();\n\n  constructor(\n    @Optional() @Inject(GLOBALS) private globalConfig: Options,\n    private service: SortablejsService,\n    private element: ElementRef,\n    private zone: NgZone,\n    private renderer: Renderer2,\n  ) {\n  }\n\n  ngOnInit() {\n    if (Sortable && Sortable.create) { // Sortable does not exist in angular universal (SSR)\n      this.create();\n    }\n  }\n\n  ngOnChanges(changes: { [prop in keyof SortablejsDirective]: SimpleChange }) {\n    const optionsChange: SimpleChange = changes.sortablejsOptions;\n\n    if (optionsChange && !optionsChange.isFirstChange()) {\n      const previousOptions: Options = optionsChange.previousValue;\n      const currentOptions: Options = optionsChange.currentValue;\n\n      Object.keys(currentOptions).forEach(optionName => {\n        if (currentOptions[optionName] !== previousOptions[optionName]) {\n          // use low-level option setter\n          this.sortableInstance.option(optionName, this.options[optionName]);\n        }\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.sortableInstance) {\n      this.sortableInstance.destroy();\n    }\n  }\n\n  private create() {\n    const container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;\n\n    setTimeout(() => {\n      this.sortableInstance = Sortable.create(container, this.options);\n      this.sortablejsInit.emit(this.sortableInstance);\n    }, 0);\n  }\n\n  private getBindings(): SortablejsBindings {\n    if (!this.sortablejs) {\n      return new SortablejsBindings([]);\n    } else if (this.sortablejs instanceof SortablejsBindings) {\n      return this.sortablejs;\n    } else {\n      return new SortablejsBindings([this.sortablejs]);\n    }\n  }\n\n  private get options() {\n    return {...this.optionsWithoutEvents, ...this.overridenOptions};\n  }\n\n  private get optionsWithoutEvents() {\n    return {...(this.globalConfig || {}), ...(this.sortablejsOptions || {})};\n  }\n\n  private proxyEvent(eventName: string, ...params: any[]) {\n    this.zone.run(() => { // re-entering zone, see https://github.com/SortableJS/angular-sortablejs/issues/110#issuecomment-408874600\n      if (this.optionsWithoutEvents && this.optionsWithoutEvents[eventName]) {\n        this.optionsWithoutEvents[eventName](...params);\n      }\n    });\n  }\n\n  private get isCloning() {\n    return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';\n  }\n\n  private clone<T>(item: T): T {\n    // by default pass the item through, no cloning performed\n    return (this.sortablejsCloneFunction || (subitem => subitem))(item);\n  }\n\n  private get overridenOptions(): Options {\n    // always intercept standard events but act only in case items are set (bindingEnabled)\n    // allows to forget about tracking this.items changes\n    return {\n      onAdd: (event: SortableEvent) => {\n        this.service.transfer = (items: any[]) => {\n          this.getBindings().injectIntoEvery(event.newIndex, items);\n          this.proxyEvent('onAdd', event);\n        };\n\n        this.proxyEvent('onAddOriginal', event);\n      },\n      onRemove: (event: SortableEvent) => {\n        const bindings = this.getBindings();\n\n        if (bindings.provided) {\n          if (this.isCloning) {\n            this.service.transfer(bindings.getFromEvery(event.oldIndex).map(item => this.clone(item)));\n\n            // great thanks to https://github.com/tauu\n            // event.item is the original item from the source list which is moved to the target list\n            // event.clone is a clone of the original item and will be added to source list\n            // If bindings are provided, adding the item dom element to the target list causes artifacts\n            // as it interferes with the rendering performed by the angular template.\n            // Therefore we remove it immediately and also move the original item back to the source list.\n            // (event handler may be attached to the original item and not its clone, therefore keeping\n            // the original dom node, circumvents side effects )\n            this.renderer.removeChild(event.item.parentNode, event.item);\n            this.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);\n            this.renderer.removeChild(event.clone.parentNode, event.clone);\n          } else {\n            this.service.transfer(bindings.extractFromEvery(event.oldIndex));\n          }\n\n          this.service.transfer = null;\n        }\n\n        this.proxyEvent('onRemove', event);\n      },\n      onUpdate: (event: SortableEvent) => {\n        const bindings = this.getBindings();\n        const indexes = getIndexesFromEvent(event);\n\n        bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));\n        this.proxyEvent('onUpdate', event);\n      },\n    };\n  }\n\n}\n\ninterface SortableEvent {\n  oldIndex: number;\n  newIndex: number;\n  oldDraggableIndex?: number;\n  newDraggableIndex?: number;\n  item: HTMLElement;\n  clone: HTMLElement;\n}\n","import {ModuleWithProviders, NgModule} from '@angular/core';\nimport {GLOBALS} from './globals';\nimport {SortablejsDirective} from './sortablejs.directive';\nimport {Options} from 'sortablejs';\n\n@NgModule({\n  declarations: [SortablejsDirective],\n  exports: [SortablejsDirective],\n})\nexport class SortablejsModule {\n\n  public static forRoot(globalOptions: Options): ModuleWithProviders<SortablejsModule> {\n    return {\n      ngModule: SortablejsModule,\n      providers: [\n        {provide: GLOBALS, useValue: globalOptions},\n      ],\n    };\n  }\n\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["i1.SortablejsService"],"mappings":"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"}}}